// 数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
// 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
// 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
// 示例 1:
// 输入: cost = [10, 15, 20]
// 输出: 15
// 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
//典型的动态规划，这种做法的空间还可以继续进行优化
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n =cost.length;
        int[] dp = new int[n];
        dp[0] = cost[0];   
        dp[1] = cost[1];
        for(int i=2;i<n;i++)
        {
            dp[i]=Math.min(dp[i-1],dp[i-2])+cost[i];//你要到达i，有两种情况，从i-2 跨两步上去，从i-1跨一步上去
        }
        return Math.min(dp[n-1],dp[n-2]); //你要到达顶层，有两种情况，从n-1，跨一步上去。从n-2，跨两步上去
    }
}
